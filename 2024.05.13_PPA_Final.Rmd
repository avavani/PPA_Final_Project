---
title: "Predicting Gentrification"
author: "PPA Spring 2024 Final - Contributors: Avani, Christina, & Sarah"
date: "`r Sys.Date()`"
output:
  html_document:
    keep_md: yes
    toc: yes
    theme: cosmo
    toc_float: yes
    code_folding: hide
    number_sections: no
  pdf_document:
    toc: yes
---

# Abstract
Defining and predicting gentrification is becoming more and more relevant to the average person as neighborhood residents become more concerned about getting priced out of their communities. Once something that could only be observed in hindsight, anticipating gentrification and attempting to prevent its disparate effects has become the subject of activism and counter-lobbying efforts. This report attempts to determine if gentrification can be correctly identified in Baltimore City, Maryland based on neighborhood characteristics that the average person can observe.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
library(pacman)
p_load(dplyr, ggplot2, sf, stats, tidycensus, tidyr, mapview, tigris, tmap)
```

```{r geography, include=FALSE, message=FALSE, warning=FALSE}

options(tigris_use_cache = TRUE)

md_bound <- counties(state = "MD") %>%
  st_transform("EPSG:4269") %>%
  erase_water(area_threshold = 0.9)

water_bound <- st_as_sfc(st_bbox(md_bound), crs = "EPSG:4269")

```

```{r callingacsdata, include=FALSE, message=FALSE, warning=FALSE}
#Getting my ACS Variable LIst
acs_variable_list.2012 <- load_variables(2012, 
                                         "acs5", 
                                         cache = TRUE)

acs_variable_list.2022 <- load_variables(2022, 
                                         "acs5", 
                                         cache = TRUE)

#Picking out my variables of interest
acs_vars <- c("B01001_001E",# ACS total Pop estimate
          "B25002_001E",# Estimate of total housing units
          "B25002_003E",# Number of vacant housing units
          "B19013_001E",# Median HH Income ($)
          "B02001_002E",# People describing themselves as "white alone"
          "B06009_006E", # Total graduate or professional degree
          "B07001_033E", #moved in within same county
          "B07001_049E", #moved in from same state
          "B07001_065E", #moved in different state
          "B07001_081E", #moved from abroad
          "B06009_005E", #bachelors degree
          "B25010_002E", #owner occupied household size
          "B25010_003E", #renter occupied HH size
          "B11016_002E", #family households
          "B11016_009E", #non family households
          "B25064_001E", #MEDIAN GROSS RENT
          "B25077_001E") #MEDIAN HOME VALUE

#Extracting the data for 2012
bmore_acs17 <- get_acs(
  geography = "tract", 
  variables = acs_vars,
  state = "MD", 
  county = "Baltimore City",
  year = 2017,
  output = "wide")%>%
  rename(TotalPopulation17 = B01001_001E,
      TotalHousingUnits17 = B25002_001E,
      VacantHousingUnits17 = B25002_003E,
      MedianHouseholdIncome17 = B19013_001E,
      WhiteAlone17 = B02001_002E,
      GradProfessionalDegree17 = B06009_006E,
      MovedWithinCounty17 = B07001_033E,
      MovedFromSameState17 = B07001_049E,
      MovedFromDifferentState17 = B07001_065E,
      MovedAbroad17 = B07001_081E,
      BachelorsDegree17 = B06009_005E,
      OwnerOccupiedHouseholdSize17 = B25010_002E,
      RenterOccupiedSize17 = B25010_003E,
      FamilyHouseholds17 = B11016_002E,
      NonFamilyHouseholds17 = B11016_009E,
      MedianRent17 = B25064_001E,
      MedianHomeValue17 = B25077_001E)%>%
  mutate(inflation.adjHH17 = MedianHouseholdIncome17 * 1.16)%>%
  select(GEOID,NAME,ends_with("17"))


#extracting my data for 2022
bmore_acs22 <- get_acs(
  geography = "tract", 
  variables = acs_vars,
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  output = "wide")%>%
  rename(TotalPopulation22 = B01001_001E,
      TotalHousingUnits22 = B25002_001E,
      VacantHousingUnits22 = B25002_003E,
      MedianHouseholdIncome22 = B19013_001E,
      WhiteAlone22 = B02001_002E,
      GradProfessionalDegree22 = B06009_006E,
      MovedWithinCounty22 = B07001_033E,
      MovedFromSameState22 = B07001_049E,
      MovedFromDifferentState22 = B07001_065E,
      MovedAbroad22 = B07001_081E,
      BachelorsDegree22 = B06009_005E,
      OwnerOccupiedHouseholdSize22 = B25010_002E,
      RenterOccupiedSize22 = B25010_003E,
      FamilyHouseholds22 = B11016_002E,
      NonFamilyHouseholds22 = B11016_009E,
      MedianRent22 = B25064_001E,
      MedianHomeValue22 = B25077_001E)%>%
  select(GEOID,NAME,ends_with("22"))

#one census tract has been combined in 2022. So I am adjusting this info in 2012 and joining back
changed_22 <- bmore_acs17 %>%
  filter(NAME %in% c("Census Tract 1801, Baltimore city, Maryland", 
                     "Census Tract 1802, Baltimore city, Maryland"))%>%
  dplyr::summarize(
    TotalPopulation17 = sum(TotalPopulation17),
    TotalHousingUnits17 = sum(TotalHousingUnits17),
    VacantHousingUnits17 = sum(VacantHousingUnits17),
    MedianHouseholdIncome17 = mean(MedianHouseholdIncome17),
    WhiteAlone17 = sum(WhiteAlone17),
    GradProfessionalDegree17 = sum(GradProfessionalDegree17),
    MovedWithinCounty17 = sum(MovedWithinCounty17),
    MovedFromSameState17 = sum(MovedFromSameState17),
    MovedFromDifferentState17 = sum(MovedFromDifferentState17),
    MovedAbroad17 = sum(MovedAbroad17),
    BachelorsDegree17 = sum(BachelorsDegree17),
    OwnerOccupiedHouseholdSize17 = mean(OwnerOccupiedHouseholdSize17),
    RenterOccupiedSize17 = mean(RenterOccupiedSize17),
    FamilyHouseholds17 = sum(FamilyHouseholds17),
    NonFamilyHouseholds17 = sum(NonFamilyHouseholds17),
    inflation.adjHH17 = mean(inflation.adjHH17),
    MedianRent17 = mean(MedianRent17),
    MedianHomeValue17 = mean(MedianRent17)
  ) %>%
  dplyr::mutate(
    NAME = "Census Tract 2806, Baltimore city, Maryland",
    GEOID = "24510280600"
  )

#joining back adjusted info
bmore_acs17 <- bmore_acs17 %>%
  filter(!(NAME %in% c("Census Tract 1801, Baltimore city, Maryland", 
                       "Census Tract 1802, Baltimore city, Maryland"))) %>%
  bind_rows(changed_22)

#creating large dataset
all.acs <- bmore_acs17 %>%
  left_join(bmore_acs22, by = "GEOID") %>%
  mutate(
    PopChangePct = if_else(TotalPopulation17 != 0, ((TotalPopulation22 - TotalPopulation17) / TotalPopulation17) * 100, 0),
    HUnitsPctChange = if_else(TotalHousingUnits17 != 0, ((TotalHousingUnits22 - TotalHousingUnits17) / TotalHousingUnits17) * 100, 0),
    VacantUnitsPctChange = if_else(VacantHousingUnits17 != 0, ((VacantHousingUnits22 - VacantHousingUnits17) / VacantHousingUnits17) * 100, 0),
    RentPctChange = if_else(MedianRent17 != 0, ((MedianRent22 - MedianRent17) / MedianRent17) * 100, 0),
    HomeValuePctChange = if_else(MedianHomeValue17 != 0, ((MedianHomeValue22 - MedianHomeValue17) / MedianHomeValue17) * 100, 0),
    IncPctChange = if_else(MedianHouseholdIncome17 != 0, ((MedianHouseholdIncome22 - MedianHouseholdIncome17) / MedianHouseholdIncome17) * 100, 0),
    WhiteAlonePctChange = if_else(WhiteAlone17 != 0, ((WhiteAlone22 - WhiteAlone17) / WhiteAlone17) * 100, 0),
    GradPctChange = if_else(GradProfessionalDegree17 != 0, ((GradProfessionalDegree22 - GradProfessionalDegree17) / GradProfessionalDegree17) * 100, 0),
    CountyWWMovePctChange = if_else(MovedWithinCounty17 != 0, ((MovedWithinCounty22 - MovedWithinCounty17) / MovedWithinCounty17) * 100, 0),
    SStateMovePctChange = if_else(MovedFromSameState17 != 0, ((MovedFromSameState22 - MovedFromSameState17) / MovedFromSameState17) * 100, 0),
    DiffStateMovePctChange = if_else(MovedFromDifferentState17 != 0, ((MovedFromDifferentState22 - MovedFromDifferentState17) / MovedFromDifferentState17) * 100, 0),
    AbroadMovePctChange = if_else(MovedAbroad17 != 0, ((MovedAbroad22 - MovedAbroad17) / MovedAbroad17) * 100, 0),
    BachelorsPctChange = if_else(BachelorsDegree17 != 0, ((BachelorsDegree22 - BachelorsDegree17) / BachelorsDegree17) * 100, 0),
    OOSizePctChange = if_else(OwnerOccupiedHouseholdSize17 != 0, ((OwnerOccupiedHouseholdSize22 - OwnerOccupiedHouseholdSize17) / OwnerOccupiedHouseholdSize17) * 100, 0),
    ROSizePctChange = if_else(RenterOccupiedSize17 != 0, ((RenterOccupiedSize22 - RenterOccupiedSize17) / RenterOccupiedSize17) * 100, 0),
    FamHHPctChange = if_else(FamilyHouseholds17 != 0, ((FamilyHouseholds22 - FamilyHouseholds17) / FamilyHouseholds17) * 100, 0),
    NonFamHHPctChange = if_else(NonFamilyHouseholds17 != 0, ((NonFamilyHouseholds22 - NonFamilyHouseholds17) / NonFamilyHouseholds17) * 100, 0)
  ) %>%
  mutate(NAME = coalesce(NAME.x, NAME.y)) %>%
  select(-NAME.x, -NAME.y)
```

# About Baltimore City
Baltimore City, Maryland sits on the Patapsco River and is home to over 585,000 people (2020 Census). An incredibly historic city, though Baltimore was once full of rigorous industry, unbridled American patriotism, and wealth, its late 20th century reality was plagued by extreme disinvestment, high crime, and white flight.

```{r bmorevis_data}

#2022 Median Household Income
bmore_hhinc22 <- get_acs(
  geography = "tract", 
  variables = "B19013_001",
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = TRUE 
) %>%
  select(GEOID, estimate)

#2022 Majority Non-White
bmore_nonwhite22 <- get_acs(
  geography = "tract", 
  variables = c(tot = "B03002_001", white = "B03002_003"),
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = TRUE
) %>%
  select(GEOID, variable, estimate) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(nonwhite = 1 - (white/tot))

#2022 Majority Owner
bmore_pcentoo22 <- get_acs(
  geography = "tract", 
  variables = c(tot = "B25003_001", oo = "B25003_002", ro = "B25003_003"),
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = TRUE
) %>%
  select(GEOID, variable, estimate) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(propoo = (oo/tot))

#2022 Median Home Value
bmore_hv22 <- get_acs(
  geography = "tract", 
  variables = "B25077_001",
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = TRUE 
) %>%
  select(GEOID, estimate)

#2022 Median Rent
bmore_rent22 <- get_acs(
  geography = "tract", 
  variables = "B25031_001",
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = TRUE 
) %>%
  select(GEOID, estimate)

```

:::: {style="display: flex;"}

::: {}

```{r bmorevis_mapcol1, message=FALSE, warning=FALSE}
 
#2022 Median Household Income
ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = bmore_hhinc22, aes(fill = estimate), col = "transparent") +
  scale_fill_gradient(
    high = "#00473B",
    low = "#A1E4CC",
    labels = scales::dollar) +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Median Household Income",
       title = "2022 Median Household Income",
       subtitle = "Baltimore City, MD")

#2022 Median Home Value
ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = bmore_hv22, aes(fill = estimate), col = "transparent") +
  scale_fill_gradient(
    high = "orangered4",
    low = "lightgoldenrod1",
    labels = scales::dollar) +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Median Home Value",
       title = "2022 Median Home Value",
       subtitle = "Baltimore City, MD")

```

:::

::: {}

```{r bmorevis_mapcol2, message=FALSE, warning=FALSE}

#2022 Majority Non-White
ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = bmore_nonwhite22, aes(fill = nonwhite), col = "transparent") +
  scale_fill_gradient(
    high = "#4F0070",
    low = "#A169E6",
    labels = scales::percent) +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Percent Non-White",
       title = "2022 Race/Ethnicity",
       subtitle = "Baltimore City, MD")

#2022 Median Rent
ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = bmore_rent22, aes(fill = estimate), col = "transparent") +
  scale_fill_gradient(
    high = "#344713",
    low = "#C9E5A8",
    labels = scales::dollar) +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Median Gross Rent",
       title = "2022 Median Gross Rent",
       subtitle = "Baltimore City, MD")

#2022 Majority Owner
# ggplot() +
#   geom_sf(data = water_bound, fill = "steelblue") +
#   geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
#   geom_sf(data = bmore_pcentoo22, aes(fill = propoo), col = "transparent") +
#   scale_fill_gradient(
#     high = "#1E1670",
#     low = "#628CE5",
#     labels = scales::percent) +
#   theme_void() +
#   xlim(-76.75, -76.48) +
#   ylim(39.2, 39.38) +
#   theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
#   labs(fill = "Percent Owner-Occupied",
#        title = "2022 Tenure",
#        subtitle = "Baltimore City, MD")


```

:::

::::

Baltimore is less than an hour North of Annapolis, MD (the state capital) and Washington, DC as the crow drives. Baltimore/Washington International Airport (BWI) does not lie within Baltimore City boundaries.

misplaced below?

```{r callingincomedata}
#Getting population by Income numbers
bmore_ctmedhhinc12 <- get_acs(
  geography = "tract", 
  variables = c(tot = "B19001_001", 
                L = "B19001_002", L = "B19001_003", L = "B19001_004", L = "B19001_005", L = "B19001_006",
                H = "B19001_007", H = "B19001_008", H = "B19001_009", H = "B19001_010", H = "B19001_011", 
                H = "B19001_012", H = "B19001_013", H = "B19001_014", H = "B19001_015", H = "B19001_016", 
                H = "B19001_017"),
  state = "MD", 
  county = "Baltimore City",
  year = 2012,
  geometry = FALSE 
) %>%
  select(GEOID, variable, estimate) %>%
  rename(est12 = estimate, var12 = variable) %>%
  group_by(GEOID, var12) %>%
  summarise(est12 = sum(est12)) %>%
  pivot_wider(names_from = var12, values_from = est12) %>%
  mutate(percentHighInc12 = H/tot, percentLowInc12 = L/tot)

#adjusting for joined census tracts
changed_22Inc <- bmore_ctmedhhinc12 %>%
  filter(GEOID %in% c("24510180100", "24510180200")) %>%
  ungroup() %>%
  summarize(H = sum(H), L = sum(L), tot = sum(tot)) %>%
  mutate(percentHighInc12 = H / tot,
         percentLowInc12 = L / tot) %>%
  mutate(GEOID = "24510280600")

#joining info back to 2012
bmore_ctmedhhinc12 <- bmore_ctmedhhinc12 %>%
  ungroup()%>%
  filter(!(GEOID %in% c("24510180100", "24510180200"))) %>%
  bind_rows(changed_22Inc)

#getting HH income for 2022
bmore_ctmedhhinc22 <- get_acs(
  geography = "tract", 
  variables = c(tot = "B19001_001", 
                L = "B19001_002", L = "B19001_003", L = "B19001_004", L = "B19001_005", L = "B19001_006",
                L = "B19001_007", L = "B19001_008", L = "B19001_009", H = "B19001_010", H = "B19001_011", 
                H = "B19001_012", H = "B19001_013", H = "B19001_014", H = "B19001_015", H = "B19001_016", 
                H = "B19001_017"),
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = FALSE 
) %>%
  select(GEOID, variable, estimate) %>%
  rename(est22 = estimate, var22 = variable) %>%
  group_by(GEOID, var22) %>%
  summarise(est22 = sum(est22)) %>%
  pivot_wider(names_from = var22, values_from = est22) %>%
  mutate(percentHighInc22 = H/tot, percentLowInc22 = L/tot)
```

```{r makingindex, eval=FALSE, include=FALSE}
#joining all
bmore_hhinc_change <- left_join(bmore_ctmedhhinc12, bmore_ctmedhhinc22, by = "GEOID") %>%
  select(GEOID, percentHighInc12, percentHighInc22, percentLowInc12, percentLowInc22)

#creating my final dataset
all.acs <- left_join(all.acs, bmore_hhinc_change)%>%
  mutate(ChangeInHighIncPct = (percentHighInc22 - percentHighInc12),
         ChangeInLowIncPct = (percentLowInc22 - percentLowInc12))

#getting my index
all.acs <- all.acs %>%
  mutate(genindex = ChangeInLowIncPct)%>%
  mutate(gentrify = case_when((genindex > (quantile(all.acs$genindex, 0.75, na.rm = TRUE)))~ 1,
         TRUE ~ 0))
```

```{r joiningviz1, eval=FALSE, include=FALSE}
baltimore_tracts <- tracts(state = "MD", county = "Baltimore City", year = 2022)
all.acs.sf <- left_join(baltimore_tracts, all.acs, by = "GEOID")

tm_shape(all.acs.sf)+
  tm_polygons(fill = "gentrify")
```


misplaced above?

# Defining Gentrification
We define our Gentrification Index per CT as [ (∆ High Income Proportion) - (∆ Low Income Proportion) ]. The change is calculated by subtracting the 2012 values from the 2022 values. If the change in proportion of high income residents is below 1, and the change in proportion of low income residents is above 1, then the equation would result in a negative number and would indicate that more poor residents have “moved” in - and would not indicate the occurrence of gentrification. If the change in proportion of high income residents is above 1, and the change in proportion of low income residents is below 1, then the equation would result in a positive number and would indicate that more wealthy residents have “moved” in - a key indicator of gentrification. 

This index was then normalized to reflect entirely positive numbers between 0 and 1. But did we take the 30th percentile of all the results or of the ones that count as gentrified? I think we should take a percentile of the ones that appear to be above 0 before the normalization. Flag to discuss.

```{r callingincomedata2}
#Getting population by Income numbers
bmore_ctmedhhinc12 <- get_acs(
  geography = "tract", 
  variables = c(tot = "B19001_001", 
                L = "B19001_002", L = "B19001_003", L = "B19001_004", L = "B19001_005", L = "B19001_006",
                H = "B19001_007", H = "B19001_008", H = "B19001_009", H = "B19001_010", H = "B19001_011", 
                H = "B19001_012", H = "B19001_013", H = "B19001_014", H = "B19001_015", H = "B19001_016", 
                H = "B19001_017"),
  state = "MD", 
  county = "Baltimore City",
  year = 2012,
  geometry = FALSE 
) %>%
  select(GEOID, variable, estimate) %>%
  rename(est12 = estimate, var12 = variable) %>%
  group_by(GEOID, var12) %>%
  summarise(est12 = sum(est12)) %>%
  pivot_wider(names_from = var12, values_from = est12) %>%
  mutate(percentHighInc12 = H/tot, percentLowInc12 = L/tot)

#adjusting for joined census tracts
changed_22Inc <- bmore_ctmedhhinc12 %>%
  filter(GEOID %in% c("24510180100", "24510180200")) %>%
  ungroup() %>%
  summarize(H = sum(H), L = sum(L), tot = sum(tot)) %>%
  mutate(percentHighInc12 = H / tot,
         percentLowInc12 = L / tot) %>%
  mutate(GEOID = "24510280600")

#joining info back to 2012
bmore_ctmedhhinc12 <- bmore_ctmedhhinc12 %>%
  ungroup()%>%
  filter(!(GEOID %in% c("24510180100", "24510180200"))) %>%
  bind_rows(changed_22Inc)

#getting HH income for 2022
bmore_ctmedhhinc22 <- get_acs(
  geography = "tract", 
  variables = c(tot = "B19001_001", 
                L = "B19001_002", L = "B19001_003", L = "B19001_004", L = "B19001_005", L = "B19001_006",
                L = "B19001_007", L = "B19001_008", L = "B19001_009", H = "B19001_010", H = "B19001_011", 
                H = "B19001_012", H = "B19001_013", H = "B19001_014", H = "B19001_015", H = "B19001_016", 
                H = "B19001_017"),
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = FALSE 
) %>%
  select(GEOID, variable, estimate) %>%
  rename(est22 = estimate, var22 = variable) %>%
  group_by(GEOID, var22) %>%
  summarise(est22 = sum(est22)) %>%
  pivot_wider(names_from = var22, values_from = est22) %>%
  mutate(percentHighInc22 = H/tot, percentLowInc22 = L/tot)
```

```{r makingindex2}
#joining all
bmore_hhinc_change <- left_join(bmore_ctmedhhinc12, bmore_ctmedhhinc22, by = "GEOID") %>%
  select(GEOID, percentHighInc12, percentHighInc22, percentLowInc12, percentLowInc22)

#creating my final dataset
all.acs <- left_join(all.acs, bmore_hhinc_change)%>%
  mutate(ChangeInHighIncPct = (percentHighInc22 - percentHighInc12),
         ChangeInLowIncPct = (percentLowInc22 - percentLowInc12))

all.acs <- all.acs%>%
  mutate(genindex = ChangeInLowIncPct)%>%
  mutate(gentrify = case_when((genindex > (quantile(all.acs$genindex, 0.70, na.rm = TRUE)))~ 1,
         TRUE ~ 0))
```

```{r joiningviz12}
baltimore_tracts <- tracts(state = "MD", county = "Baltimore City", year = 2022)
all.acs.sf <- left_join(baltimore_tracts, all.acs, by = "GEOID")

tm_shape(all.acs.sf)+
  tm_polygons(fill = "gentrify")
```

# Data Collection
For testing the ability to predict gentrification, input features that could be observed by eye were sourced, cleaned, and used in the model. Our data sources primarily included the 2012 and 2022 5-year ACS (American Community Survey) from the U.S. Census Bureau and Open Baltimore (https://data.baltimorecity.gov/). 

```{r bmore_data, message=FALSE, warning=FALSE}

#Open-Bid List - Vacants to Value 
bmore_bids <- st_read("https://egisdata.baltimorecity.gov/egis/rest/services/Housing/DHCD_Open_Baltimore_Datasets/FeatureServer/7/query?outFields=*&where=1%3D1&f=geojson")%>%
  st_transform(crs = st_crs(baltimore_tracts))%>%
  st_join(baltimore_tracts)%>%
  group_by(GEOID)%>%
  tally()%>%
  st_drop_geometry()%>%
  rename(tractbids = n)

#Universities & colleges? 
bmore_colleges <- st_read("https://services1.arcgis.com/UWYHeuuJISiGmgXx/arcgis/rest/services/Universities_and_Colleges/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson")%>%
  st_transform(crs = st_crs(baltimore_tracts))

#Businesses by community statistical areas 
bmore_business <- st_read("https://services1.arcgis.com/mVFRs7NF4iFitgbY/arcgis/rest/services/Neiind/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson")%>%
  mutate(changebiz = neiind19 - neiind10)%>%
  select(CSA2010, neiind21, geometry, changebiz) %>%
  rename(CSA = CSA2010, 
         business_count = neiind21)
 
#Percentage of vacant lots 
bmore_p_lots <- st_read("https://services1.arcgis.com/mVFRs7NF4iFitgbY/arcgis/rest/services/Vacant/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson") %>%
  select(CSA2020, vacant21, geometry) %>%
  rename(CSA = CSA2020, 
         p_vacant = vacant21)

#Baltimore schools

school_outcome <- st_read("https://services1.arcgis.com/mVFRs7NF4iFitgbY/arcgis/rest/services/Pread3/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson")%>%
  select(CSA2010, pread317, geometry) %>%
  rename(CSA = CSA2010,
         p_students = pread317)%>%
  st_centroid()

#walk score
walk_score <- st_read("https://services1.arcgis.com/mVFRs7NF4iFitgbY/arcgis/rest/services/Wlksc/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson")%>%
  mutate(changewalk = wlksc17 - wlksc11)%>%
  select(CSA2010, wlksc17, geometry, changewalk) %>%
  rename(CSA = CSA2010,
         walk_score = wlksc17)%>%
  st_centroid()

```


## Joining additional metrics

```{r}
p_load(nngeo,FNN,tibble, caret)
bmore_hoods <- bmore_p_lots %>%
  select(-p_vacant)

bmore_CSA_data <- bmore_p_lots %>%
  st_drop_geometry()%>%
  left_join(bmore_business)%>%
  st_as_sf()

bmore_CSA_data <- st_join(bmore_CSA_data, school_outcome, left = TRUE)

bmore_CSA_data <- st_join(bmore_CSA_data, walk_score, left = TRUE)

coldist <- baltimore_tracts
coldist$nearest_college_index <- st_nearest_feature(coldist, bmore_colleges)
coldist <- coldist %>%
  rowwise() %>%
  mutate(nearest_college = list(bmore_colleges[nearest_college_index, ]))
coldist <- coldist %>%
  mutate(coldist = st_distance(geometry, nearest_college$geometry))%>%
  select(-nearest_college_index,
         -nearest_college)%>%
  rename(collegedist = coldist)%>%
  st_drop_geometry()

acs.hoods <- all.acs.sf %>%
  st_transform(crs = st_crs(bmore_hoods))%>%
  st_centroid()%>%
  st_join(bmore_hoods, join = st_intersects)%>%
  st_drop_geometry()%>%
  left_join(bmore_CSA_data)%>%
  mutate(NAME = coalesce(NAME.x, NAME.y)) %>%
  select(-NAME.x, -NAME.y)

acs.hoods <- acs.hoods %>%
  left_join(coldist)

acs.hoods <- acs.hoods %>%
  select(-STATEFP,
         -COUNTYFP,
         -TRACTCE,
         -NAMELSAD,
         -MTFCC,
         -FUNCSTAT,
         -ALAND,
         -AWATER,
         -INTPTLAT,
         -INTPTLON,
         -NAME) %>%
  mutate(CSA = coalesce(CSA.x, CSA.y)) %>%
  select(-CSA.x, -CSA.y)%>%
  st_drop_geometry()%>%
  select(-geometry)%>%
  left_join(bmore_bids)%>%
  mutate(across(where(is.numeric), ~replace_na(., 0)),
         across(where(is.character), ~replace_na(., "Unknown")))
```

# Model Development & Testing

```{r modelling, warning=FALSE, message=FALSE}
p_load(stargazer)

all.acs.reg <- acs.hoods %>%
  select(-(ends_with("22")),
         -(ends_with("12")),
         -genindex,
         -CSA,
         -MovedWithinCounty17,
         -MovedFromSameState17,
         -MovedFromDifferentState17,
         -MovedAbroad17,
         OOSizePctChange,
         ROSizePctChange)

train <- all.acs.reg %>%
  sample_frac(.75)

train_index <- as.numeric(rownames(train))

test <- all.acs.reg[-train_index, ]

reg.gentrify <- glm(gentrify ~ ., data = 
                    train %>%
                      select(-GEOID,
                             -ChangeInLowIncPct,
                             -ChangeInHighIncPct),
                    family = "binomial"(link = "logit"))

stargazer(reg.gentrify, type = "text", out = "regression_summary.txt", title = "Regression Results", 
          label = "tab:regression_results", align = TRUE, 
          ci = TRUE, ci.level = 0.95, single.row = TRUE, 
          star.cutoffs = c(0.05, 0.01, 0.001), 
          notes = c("*** p<0.001", "** p<0.01", "* p<0.05"), 
          notes.align = "l", notes.label = "Significance levels:")
```

Testing the outcomes. 

```{r confusionmatrix, warning=FALSE, message=FALSE}
testProbs <- 
  data.frame(class = test$gentrify,
             probs = predict(reg.gentrify, test, type = "response"))

testProbs %>%
  mutate(predClass = ifelse(probs >= .5, "1", "0"), 
         predClass = factor(predClass, levels = c("0", "1")),  
         class = factor(class, levels = c("0", "1"))) %>% 
  { caret::confusionMatrix(.$predClass, .$class, positive = "1") }
```

More stuff

```{r probdist, warning=FALSE, message=FALSE}
p_load(ggplot2)
palette_4_colors <- c("#e4572e","#17bebb","#ffc914","#A379C9")
root.dir = "https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/DATA/"
source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")

ggplot(testProbs, aes(x = probs, fill = as.factor(class))) + 
  geom_density() +
  facet_grid(class ~ .) +
  scale_fill_manual(values = palette_4_colors) + xlim(0, 1) +
  labs(x = "Gentrify", y = "Density of probabilities",
       title = "Distribution of predicted probabilities by observed outcome") +
  plotTheme() + theme(strip.text.x = element_text(size = 18),
        legend.position = "none")+
  theme(text = element_text(family = "Times New Roman", size = 12), 
        plot.title = element_text(face = "bold", size = 14),
        plot.subtitle = element_text(size = 12),
        plot.caption = element_text(size = 8))
```

# Validation

More of the stuff. This time calling up a ROC curve. 

```{r ROCcurve, warning=FALSE, message=FALSE}
p_load(pROC)

iterateThresholds <- function(data, observedClass, predictedProbs) {
  observedClass <- enquo(observedClass)
  predictedProbs <- enquo(predictedProbs)
  
  x <- 0.01
  all_prediction <- data.frame()
  
  while (x <= 1) {
    this_prediction <- data %>%
      mutate(predclass = ifelse(!!predictedProbs > x, 1, 0)) %>%
      count(predclass, !!observedClass) %>%
      summarize(
        Count_TN = sum(n[predclass == 0 & !!observedClass == 0]),
        Count_TP = sum(n[predclass == 1 & !!observedClass == 1]),
        Count_FN = sum(n[predclass == 0 & !!observedClass == 1]),
        Count_FP = sum(n[predclass == 1 & !!observedClass == 0]),
        Rate_TP = Count_TP / (Count_TP + Count_FN),
        Rate_FP = Count_FP / (Count_FP + Count_TN),
        Rate_FN = Count_FN / (Count_FN + Count_TP),
        Rate_TN = Count_TN / (Count_TN + Count_FP),
        Accuracy = (Count_TP + Count_TN) / (Count_TP + Count_TN + Count_FN + Count_FP),
        Threshold = round(x, 2),
        .groups = 'drop'
      )
    
    all_prediction <- rbind(all_prediction, this_prediction)
    x <- x + .01
  }
  
  return(all_prediction)
}

testProbs.thresholds <- iterateThresholds(
  data = testProbs, 
  observedClass = class, 
  predictedProbs = probs
)

ggplot(testProbs.thresholds, aes(x = Threshold)) +
  geom_line(aes(y = Accuracy, color = "Accuracy")) +
  geom_line(aes(y = Rate_TP, color = "True Positive Rate")) +
  geom_line(aes(y = Rate_FP, color = "False Positive Rate")) +
  scale_color_manual(values = c("Accuracy" = "blue", "True Positive Rate" = "green", "False Positive Rate" = "red")) +
  labs(title = "Model Performance Across Different Thresholds",
       x = "Threshold", y = "Rate") +
  theme_minimal() +
  theme(legend.title = element_blank(),
        legend.position = "bottom",
        text = element_text(family = "Times New Roman", size = 12),
        plot.title = element_text(face = "bold", size = 14),
        plot.subtitle = element_text(size = 12),
        plot.caption = element_text(size = 8))
```

ROC curve

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
p_load(gridExtra)

aucTable <- testProbs %>% 
  summarize(AUC = as.numeric(auc(roc(class, probs)))) %>% 
  mutate(AUC = as.character(round(AUC, 3)))

mutate(testProbs.thresholds, pointSize = ifelse(Threshold == .48, 24, 16)) %>%
  ggplot(aes(Rate_FP, Rate_TP)) + 
  geom_point(aes(shape = pointSize)) + geom_line() + scale_shape_identity() +
  geom_abline(slope = 1, intercept = 0, size = 1.5, color = 'grey') +
  annotation_custom(tableGrob(aucTable, rows = NULL), xmin = .45, xmax = 1, ymin = 0, ymax = .45) +
  labs(title="ROC Curves", x="False Positive Rate", y="True Positive Rate") +
  plotTheme()+
  theme(text = element_text(family = "Times New Roman", size = 12), 
        plot.title = element_text(face = "bold", size = 14),
        plot.subtitle = element_text(size = 12),
        plot.caption = element_text(size = 8))
```

# Conclusion
