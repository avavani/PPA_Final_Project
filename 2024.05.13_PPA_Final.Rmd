---
title: "Predicting Gentrification"
author: "PPA Spring 2024 Final - Contributors: Avani, Christina, & Sarah"
date: "`r Sys.Date()`"
output:
  html_document:
    keep_md: yes
    toc: yes
    theme: cosmo
    toc_float: yes
    code_folding: hide
    number_sections: no
  pdf_document:
    toc: yes
---

# Abstract

Defining and predicting gentrification is becoming more and more relevant to the average person as neighborhood residents become more concerned about getting priced out of their communities. Once something that could only be observed in hindsight, anticipating gentrification and attempting to prevent its disparate effects has become the subject of activism and counter-lobbying efforts. This report attempts to determine if gentrification can be correctly identified in Baltimore City, Maryland based on neighborhood characteristics that the average person can observe.

```{r setup, include=FALSE, , warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
library(pacman)
library(dplyr)
p_load(ggplot2, sf, stats, tidycensus, tidyr, mapview, tigris, tmap, tidyverse)
```

```{r geography, include=FALSE, message=FALSE, warning=FALSE, cache=TRUE}

options(tigris_use_cache = TRUE)

md_bound <- counties(state = "MD") %>%
  st_transform("EPSG:4269") %>%
  erase_water(area_threshold = 0.9)

water_bound <- st_as_sfc(st_bbox(md_bound), crs = "EPSG:4269")

patapsco <- st_read("https://gisdata.baltimorecity.gov/egis/rest/services/OpenBaltimore/Water/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson")

bmorecsa <- st_read("https://services1.arcgis.com/mVFRs7NF4iFitgbY/arcgis/rest/services/Community_Statistical_Areas_(CSAs)__Reference_Boundaries/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson")

```

```{r callingacsdata, include=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
#Picking out my variables of interest
acs_vars <- c("B01001_001E",# ACS total Pop estimate
          "B25002_001E",# Estimate of total housing units
          "B25002_003E",# Number of vacant housing units
          "B19013_001E",# Median HH Income ($)
          "B02001_002E",# People describing themselves as "white alone"
          "B06009_006E", # Total graduate or professional degree
          "B07001_033E", #moved in within same county
          "B07001_049E", #moved in from same state
          "B07001_065E", #moved in different state
          "B07001_081E", #moved from abroad
          "B06009_005E", #bachelors degree
          "B25010_002E", #owner occupied household size
          "B25010_003E", #renter occupied HH size
          "B11016_002E", #family households
          "B11016_009E", #non family households
          "B25064_001E", #MEDIAN GROSS RENT
          "B25077_001E") #MEDIAN HOME VALUE

#Extracting the data for 2012
bmore_acs17 <- get_acs(
  geography = "tract", 
  variables = acs_vars,
  state = "MD", 
  county = "Baltimore City",
  year = 2017,
  output = "wide")%>%
  rename(TotalPopulation17 = B01001_001E,
      TotalHousingUnits17 = B25002_001E,
      VacantHousingUnits17 = B25002_003E,
      MedianHouseholdIncome17 = B19013_001E,
      WhiteAlone17 = B02001_002E,
      GradProfessionalDegree17 = B06009_006E,
      MovedWithinCounty17 = B07001_033E,
      MovedFromSameState17 = B07001_049E,
      MovedFromDifferentState17 = B07001_065E,
      MovedAbroad17 = B07001_081E,
      BachelorsDegree17 = B06009_005E,
      OwnerOccupiedHouseholdSize17 = B25010_002E,
      RenterOccupiedSize17 = B25010_003E,
      FamilyHouseholds17 = B11016_002E,
      NonFamilyHouseholds17 = B11016_009E,
      MedianRent17 = B25064_001E,
      MedianHomeValue17 = B25077_001E)%>%
  mutate(inflation.adjHH17 = MedianHouseholdIncome17 * 1.16,
         MedianRent17 = MedianRent17 * 1.16,
         MedianHomeValue17 = MedianHomeValue17 *1.16)%>%
  select(GEOID,NAME,ends_with("17"))


#extracting my data for 2022
bmore_acs22 <- get_acs(
  geography = "tract", 
  variables = acs_vars,
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  output = "wide")%>%
  rename(TotalPopulation22 = B01001_001E,
      TotalHousingUnits22 = B25002_001E,
      VacantHousingUnits22 = B25002_003E,
      MedianHouseholdIncome22 = B19013_001E,
      WhiteAlone22 = B02001_002E,
      GradProfessionalDegree22 = B06009_006E,
      MovedWithinCounty22 = B07001_033E,
      MovedFromSameState22 = B07001_049E,
      MovedFromDifferentState22 = B07001_065E,
      MovedAbroad22 = B07001_081E,
      BachelorsDegree22 = B06009_005E,
      OwnerOccupiedHouseholdSize22 = B25010_002E,
      RenterOccupiedSize22 = B25010_003E,
      FamilyHouseholds22 = B11016_002E,
      NonFamilyHouseholds22 = B11016_009E,
      MedianRent22 = B25064_001E,
      MedianHomeValue22 = B25077_001E)%>%
  select(GEOID,NAME,ends_with("22"))

#one census tract has been combined in 2022. So I am adjusting this info in 2012 and joining back
changed_22 <- bmore_acs17 %>%
  filter(NAME %in% c("Census Tract 1801, Baltimore city, Maryland", 
                     "Census Tract 1802, Baltimore city, Maryland"))%>%
  dplyr::summarize(
    TotalPopulation17 = sum(TotalPopulation17),
    TotalHousingUnits17 = sum(TotalHousingUnits17),
    VacantHousingUnits17 = sum(VacantHousingUnits17),
    MedianHouseholdIncome17 = mean(MedianHouseholdIncome17),
    WhiteAlone17 = sum(WhiteAlone17),
    GradProfessionalDegree17 = sum(GradProfessionalDegree17),
    MovedWithinCounty17 = sum(MovedWithinCounty17),
    MovedFromSameState17 = sum(MovedFromSameState17),
    MovedFromDifferentState17 = sum(MovedFromDifferentState17),
    MovedAbroad17 = sum(MovedAbroad17),
    BachelorsDegree17 = sum(BachelorsDegree17),
    OwnerOccupiedHouseholdSize17 = mean(OwnerOccupiedHouseholdSize17),
    RenterOccupiedSize17 = mean(RenterOccupiedSize17),
    FamilyHouseholds17 = sum(FamilyHouseholds17),
    NonFamilyHouseholds17 = sum(NonFamilyHouseholds17),
    inflation.adjHH17 = mean(inflation.adjHH17),
    MedianRent17 = mean(MedianRent17),
    MedianHomeValue17 = mean(MedianRent17)
  ) %>%
  dplyr::mutate(
    NAME = "Census Tract 2806, Baltimore city, Maryland",
    GEOID = "24510280600"
  )

#joining back adjusted info
bmore_acs17 <- bmore_acs17 %>%
  filter(!(NAME %in% c("Census Tract 1801, Baltimore city, Maryland", 
                       "Census Tract 1802, Baltimore city, Maryland"))) %>%
  bind_rows(changed_22)


all.acs <- bmore_acs17 %>%
  left_join(bmore_acs22, by = "GEOID") %>%
  mutate(
    PopChangePct = if_else(TotalPopulation17 != 0, ((TotalPopulation22 - TotalPopulation17) / TotalPopulation17) * 100, 0),
    HUnitsPctChange = if_else(TotalHousingUnits17 != 0, ((TotalHousingUnits22 - TotalHousingUnits17) / TotalHousingUnits17) * 100, 0),
    VacantUnitsPctChange = if_else(VacantHousingUnits17 != 0, ((VacantHousingUnits22 - VacantHousingUnits17) / VacantHousingUnits17) * 100, 0),
    RentPctChange = if_else(MedianRent17 != 0, ((MedianRent22 - MedianRent17) / MedianRent17) * 100, 0),
    HomeValuePctChange = if_else(MedianHomeValue17 != 0, ((MedianHomeValue22 - MedianHomeValue17) / MedianHomeValue17) * 100, 0),
    IncPctChange = if_else(MedianHouseholdIncome17 != 0, ((MedianHouseholdIncome22 - MedianHouseholdIncome17) / MedianHouseholdIncome17) * 100, 0),
    WhiteAlonePct17 = if_else(TotalPopulation17 != 0, WhiteAlone17 / TotalPopulation17 * 100, 0),
    WhiteAlonePct22 = if_else(TotalPopulation22 != 0, WhiteAlone22 / TotalPopulation22 * 100, 0),
    GradPct17 = if_else(TotalPopulation17 != 0, GradProfessionalDegree17 / TotalPopulation17 * 100, 0),
    GradPct22 = if_else(TotalPopulation22 != 0, GradProfessionalDegree22 / TotalPopulation22 * 100, 0),
    CountyWWMovePct17 = if_else(TotalPopulation17 != 0, MovedWithinCounty17 / TotalPopulation17 * 100, 0),
    CountyWWMovePct22 = if_else(TotalPopulation22 != 0, MovedWithinCounty22 / TotalPopulation22 * 100, 0),
    SStateMovePct17 = if_else(TotalPopulation17 != 0, MovedFromSameState17 / TotalPopulation17 * 100, 0),
    SStateMovePct22 = if_else(TotalPopulation22 != 0, MovedFromSameState22 / TotalPopulation22 * 100, 0),
    DiffStateMovePct17 = if_else(TotalPopulation17 != 0, MovedFromDifferentState17 / TotalPopulation17 * 100, 0),
    DiffStateMovePct22 = if_else(TotalPopulation22 != 0, MovedFromDifferentState22 / TotalPopulation22 * 100, 0),
    AbroadMovePct17 = if_else(TotalPopulation17 != 0, MovedAbroad17 / TotalPopulation17 * 100, 0),
    AbroadMovePct22 = if_else(TotalPopulation22 != 0, MovedAbroad22 / TotalPopulation22 * 100, 0),
    BachelorsPct17 = if_else(TotalPopulation17 != 0, BachelorsDegree17 / TotalPopulation17 * 100, 0),
    BachelorsPct22 = if_else(TotalPopulation22 != 0, BachelorsDegree22 / TotalPopulation22 * 100, 0),
    WhiteAlonePctChange = if_else(WhiteAlonePct17 != 0, ((WhiteAlonePct22 - WhiteAlonePct17) / WhiteAlonePct17) * 100, 0),
    GradPctChange = if_else(GradPct17 != 0, ((GradPct22 - GradPct17) / GradPct17) * 100, 0),
    CountyWWMovePctChange = if_else(CountyWWMovePct17 != 0, ((CountyWWMovePct22 - CountyWWMovePct17) / CountyWWMovePct17) * 100, 0),
    SStateMovePctChange = if_else(SStateMovePct17 != 0, ((SStateMovePct22 - SStateMovePct17) / SStateMovePct17) * 100, 0),
    DiffStateMovePctChange = if_else(DiffStateMovePct17 != 0, ((DiffStateMovePct22 - DiffStateMovePct17) / DiffStateMovePct17) * 100, 0),
    AbroadMovePctChange = if_else(AbroadMovePct17 != 0, ((AbroadMovePct22 - AbroadMovePct17) / AbroadMovePct17) * 100, 0),
    BachelorsPctChange = if_else(BachelorsPct17 != 0, ((BachelorsPct22 - BachelorsPct17) / BachelorsPct17) * 100, 0),
     OOSizePctChange = if_else(OwnerOccupiedHouseholdSize17 != 0, ((OwnerOccupiedHouseholdSize22 - OwnerOccupiedHouseholdSize17) / OwnerOccupiedHouseholdSize17) * 100, 0),
    ROSizePctChange = if_else(RenterOccupiedSize17 != 0, ((RenterOccupiedSize22 - RenterOccupiedSize17) / RenterOccupiedSize17) * 100, 0),
    FamHHPctChange = if_else(FamilyHouseholds17 != 0, ((FamilyHouseholds22 - FamilyHouseholds17) / FamilyHouseholds17) * 100, 0),
    NonFamHHPctChange = if_else(NonFamilyHouseholds17 != 0, ((NonFamilyHouseholds22 - NonFamilyHouseholds17) / NonFamilyHouseholds17) * 100, 0)
  ) %>%
  mutate(NAME = coalesce(NAME.x, NAME.y)) %>%
  select(-NAME.x, -NAME.y) %>%
  mutate(across(where(is.numeric), ~replace_na(., 0)),
         across(where(is.numeric), ~replace(., is.infinite(.), 0))) 

```

# About Baltimore City

Baltimore City, Maryland sits on the Patapsco River and is home to over 585,000 people (2020 Census). An incredibly historic city, though Baltimore was once full of rigorous industry, unbridled American patriotism, and wealth, its late 20th century reality was plagued by extreme disinvestment, high crime, and white flight.

Baltimore City is considered one of the most segregated cities in the United States, where neighborhoods are often predominantly white or predominantly Black and Hispanic. Coined, "The Butterfly Effect," the central spine running North-South is where communities are majority-white, have higher median incomes, and typically have lower health risks. The wings of Baltimore are where rents and home values are low are where more people of color live. 

::: {style="display: flex;"}

::: {}

```{r tragedy, message=FALSE, warning=FALSE, include=FALSE}

#2022 Median Household Income
bmore_hhinc22 <- get_acs(
  geography = "tract", 
  variables = "B19013_001",
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = TRUE 
) %>%
  select(GEOID, estimate)

#2022 Majority Non-White
bmore_nonwhite22 <- get_acs(
  geography = "tract", 
  variables = c(tot = "B03002_001", white = "B03002_003"),
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = TRUE
) %>%
  select(GEOID, variable, estimate) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(nonwhite = 1 - (white/tot))

#2022 Majority Owner
bmore_pcentoo22 <- get_acs(
  geography = "tract", 
  variables = c(tot = "B25003_001", oo = "B25003_002", ro = "B25003_003"),
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = TRUE
) %>%
  select(GEOID, variable, estimate) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  mutate(propoo = (oo/tot))

#2022 Median Home Value
bmore_hv22 <- get_acs(
  geography = "tract", 
  variables = "B25077_001",
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = TRUE 
) %>%
  select(GEOID, estimate)

#2022 Median Rent
bmore_rent22 <- get_acs(
  geography = "tract", 
  variables = "B25031_001",
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = TRUE 
) %>%
  select(GEOID, estimate)
```

```{r bmorevis_mapcol1, echo=FALSE, message=FALSE, warning=FALSE}
#2022 Median Household Income
ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = bmore_hhinc22, aes(fill = estimate), col = "transparent") +
  scale_fill_gradient(
    high = "#00473B",
    low = "#A1E4CC",
    labels = scales::dollar) +
  geom_sf(data = patapsco, fill = "steelblue", col = "transparent") +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Median Household Income",
       title = "2022 Median Household Income",
       subtitle = "Baltimore City, MD", 
       caption = "Source: 5-year ACS, U.S. Census Bureau")

#2022 Median Home Value
ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = bmore_hv22, aes(fill = estimate), col = "transparent") +
  scale_fill_gradient(
    high = "orangered4",
    low = "lightgoldenrod1",
    labels = scales::dollar) +
  geom_sf(data = patapsco, fill = "steelblue", col = "transparent") +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Median Home Value",
       title = "2022 Median Home Value",
       subtitle = "Baltimore City, MD", 
       caption = "Source: 5-year ACS, U.S. Census Bureau")

```

:::

::: {}

```{r bmorevis_mapcol2, echo=FALSE, message=FALSE, warning=FALSE}

#2022 Majority Non-White
ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = bmore_nonwhite22, aes(fill = nonwhite), col = "transparent") +
  scale_fill_gradient(
    high = "#4F0070",
    low = "#A169E6",
    labels = scales::percent) +
  geom_sf(data = patapsco, fill = "steelblue", col = "transparent") +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Percent Non-White",
       title = "2022 Race/Ethnicity",
       subtitle = "Baltimore City, MD", 
       caption = "Source: 5-year ACS, U.S. Census Bureau")

#2022 Median Rent
ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = bmore_rent22, aes(fill = estimate), col = "transparent") +
  scale_fill_gradient(
    high = "#344713",
    low = "#C9E5A8",
    labels = scales::dollar) +
  geom_sf(data = patapsco, fill = "steelblue", col = "transparent") +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Median Gross Rent",
       title = "2022 Median Gross Rent",
       subtitle = "Baltimore City, MD", 
       caption = "Source: 5-year ACS, U.S. Census Bureau")

#2022 Majority Owner
# ggplot() +
#   geom_sf(data = water_bound, fill = "steelblue") +
#   geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
#   geom_sf(data = bmore_pcentoo22, aes(fill = propoo), col = "transparent") +
#   scale_fill_gradient(
#     high = "#1E1670",
#     low = "#628CE5",
#     labels = scales::percent) +
#   theme_void() +
#   xlim(-76.75, -76.48) +
#   ylim(39.2, 39.38) +
#   theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
#   labs(fill = "Percent Owner-Occupied",
#        title = "2022 Tenure",
#        subtitle = "Baltimore City, MD")


```

:::

::::

Baltimore is less than an hour North of Annapolis, MD (the state capital) and Washington, DC as the crow drives. Baltimore/Washington International Airport (BWI) does not lie within Baltimore City boundaries.

# Defining Gentrification

Gentrification has many different definitions and connotations. At least part of its definition is intangible: often one can simply "feel" when a neighborhood has gentrified. At a glance, the clues may be found in the presence of new construction trying especially hard to look older, or in the manifestation of high-priced coffee shops and their hipster patrons where there were none before. 

The United States Department of Housing and Urban Development defines gentrification as, "a form of neighborhood change that occurs when high-income groups move to low-income areas, potentially altering the cultural and financial landscape of the original neighborhood”. 

Using this standard as a guide, we define our Gentrification Index per CT as follows:

<center> GI = (∆ High Income Proportion) + (Percent Change of Rent) + (Percent Change of Home Value) </center>

The change is calculated by subtracting the 2012 values from the 2022 values. The proportion of High Income residents per Census Tract is determined by tabulating the number of residents who make more than 80% of the AMI in Baltimore City alone during each given year. The change in Rent and Home Value were calculated based on median costs adjusted for inflation.

Once sorted in order of their Gentrification Index, we determine that the top 30th percentile of Census Tracts are extreme enough in their exhibition of the Index's ingredients to be labeled as "gentrified."

```{r callingincomedata, warning=FALSE, message=FALSE}
#Getting population by Income numbers
bmore_ctmedhhinc12 <- get_acs(
  geography = "tract", 
  variables = c(tot = "B19001_001", 
                L = "B19001_002", L = "B19001_003", L = "B19001_004", L = "B19001_005", L = "B19001_006",
                H = "B19001_007", H = "B19001_008", H = "B19001_009", H = "B19001_010", H = "B19001_011", 
                H = "B19001_012", H = "B19001_013", H = "B19001_014", H = "B19001_015", H = "B19001_016", 
                H = "B19001_017"),
  state = "MD", 
  county = "Baltimore City",
  year = 2012,
  geometry = FALSE 
) %>%
  select(GEOID, variable, estimate) %>%
  rename(est12 = estimate, var12 = variable) %>%
  group_by(GEOID, var12) %>%
  summarise(est12 = sum(est12)) %>%
  pivot_wider(names_from = var12, values_from = est12) %>%
  mutate(percentHighInc12 = H/tot, percentLowInc12 = L/tot)

#adjusting for joined census tracts
changed_22Inc <- bmore_ctmedhhinc12 %>%
  filter(GEOID %in% c("24510180100", "24510180200")) %>%
  ungroup() %>%
  summarize(H = sum(H), L = sum(L), tot = sum(tot)) %>%
  mutate(percentHighInc12 = H / tot,
         percentLowInc12 = L / tot) %>%
  mutate(GEOID = "24510280600")

#joining info back to 2012
bmore_ctmedhhinc12 <- bmore_ctmedhhinc12 %>%
  ungroup()%>%
  filter(!(GEOID %in% c("24510180100", "24510180200"))) %>%
  bind_rows(changed_22Inc)

#getting HH income for 2022
bmore_ctmedhhinc22 <- get_acs(
  geography = "tract", 
  variables = c(tot = "B19001_001", 
                L = "B19001_002", L = "B19001_003", L = "B19001_004", L = "B19001_005", L = "B19001_006",
                L = "B19001_007", L = "B19001_008", L = "B19001_009", H = "B19001_010", H = "B19001_011", 
                H = "B19001_012", H = "B19001_013", H = "B19001_014", H = "B19001_015", H = "B19001_016", 
                H = "B19001_017"),
  state = "MD", 
  county = "Baltimore City",
  year = 2022,
  geometry = FALSE 
) %>%
  select(GEOID, variable, estimate) %>%
  rename(est22 = estimate, var22 = variable) %>%
  group_by(GEOID, var22) %>%
  summarise(est22 = sum(est22)) %>%
  pivot_wider(names_from = var22, values_from = est22) %>%
  mutate(percentHighInc22 = H/tot, percentLowInc22 = L/tot)
```

```{r makingindex, include=FALSE, warning=FALSE, message=FALSE}
#joining all
bmore_hhinc_change <- left_join(bmore_ctmedhhinc12, bmore_ctmedhhinc22, by = "GEOID") %>%
  select(GEOID, percentHighInc12, percentHighInc22, percentLowInc12, percentLowInc22)

#creating my final dataset
all.acs <- left_join(all.acs, bmore_hhinc_change)%>%
  mutate(ChangeInHighIncPct = (percentHighInc22 - percentHighInc12),
         ChangeInLowIncPct = (percentLowInc22 - percentLowInc12))

#getting my index
all.acs <- all.acs %>%
  mutate(genindex = ((ChangeInHighIncPct + HomeValuePctChange + RentPctChange)))

all.acs <- all.acs %>%
mutate(gentrify = case_when((genindex > (quantile(all.acs$genindex, 0.75, na.rm = TRUE)))~ 1,
         TRUE ~ 0))
```

```{r joiningviz1, include=FALSE, warning=FALSE, message=FALSE}
baltimore_tracts <- tracts(state = "MD", county = "Baltimore City", year = 2022)
all.acs.sf <- left_join(baltimore_tracts, all.acs, by = "GEOID")%>%
  st_as_sf()
```

```{r gentrification_map, warning=FALSE, message=FALSE}

all.acs.sf.g <- all.acs.sf %>%
  dplyr::select(GEOID, gentrify) %>%
  mutate(gentrify = as.factor(gentrify))

ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = all.acs.sf, aes(fill = as.factor(gentrify)), col = "#756059") +
  scale_fill_manual(values = c("#5FA08F", "#F56A40"),
                    labels = c("No", "Yes")) +
  geom_sf(data = patapsco, fill = "steelblue", col = "transparent") +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Gentrified?",
       title = "2022 Gentrification per Census Tract",
       subtitle = "Baltimore City, MD")

```


# Data Collection

For testing the ability to predict gentrification, input features that could be observed by eye were sourced, cleaned, and used in the model. Our data sources primarily included the 2012 and 2022 5-year ACS (American Community Survey) from the U.S. Census Bureau and Open Baltimore (<https://data.baltimorecity.gov/>).

The specific features pulled based on this criteria were:

_Baltimore City Open Bid List_
The Baltimore Bids feature includes the count of city owned vacant lots and properties with vacant building notices. 

_Universities and Colleges_ 
The colleges feature includes the locations of universities and colleges in Baltimore. 

_Businesses_ 
The businesses feature contains the count of businesses in each community statistical area (CSA), which is a geographic measurement developed by the Baltimore City Planning Department to define neighborhood clusters. Ths model also includes a change in businesses feature, which accounts for the change in count of businesses per CSA from 2010 to 2019. 

_Vacant Lots_ 
The vacant lots feature includes the percentage of residential properties which have been classifies as vacant or abandoned by the City of Baltimore per CSA. 

_Baltimore Schools_ 
The schools feature highlights the percentage of students per CSA who exceeded or met the Partnership for Assessment of Readiness for College and Careers (PARCC) math expectations. 

_Walk Score_
The walk score feature includes the average walk score by CSA and the change in walk score from 2017 to 2011.

```{r bmore_data, message=FALSE, warning=FALSE, cache=TRUE, include=FALSE}
#Open-Bid List - Vacants to Value 
bmore_bids <- st_read("https://egisdata.baltimorecity.gov/egis/rest/services/Housing/DHCD_Open_Baltimore_Datasets/FeatureServer/7/query?outFields=*&where=1%3D1&f=geojson")%>%
  st_transform(crs = st_crs(baltimore_tracts))%>%
  st_join(baltimore_tracts)%>%
  group_by(GEOID)%>%
  tally()%>%
  st_drop_geometry()%>%
  rename(tractbids = n)

#Universities & colleges? 
bmore_colleges <- st_read("https://services1.arcgis.com/UWYHeuuJISiGmgXx/arcgis/rest/services/Universities_and_Colleges/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson")%>%
  st_transform(crs = st_crs(baltimore_tracts))

#Businesses by community statistical areas 
bmore_business <- st_read("https://services1.arcgis.com/mVFRs7NF4iFitgbY/arcgis/rest/services/Neiind/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson")%>%
  mutate(changebiz = neiind19 - neiind10)%>%
  select(CSA2020, neiind21, geometry, changebiz) %>%
  rename(CSA = CSA2020, 
         business_count = neiind21)
 
#Percentage of vacant lots 
bmore_p_lots <- st_read("https://services1.arcgis.com/mVFRs7NF4iFitgbY/arcgis/rest/services/Vacant/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson") %>%
  select(CSA2020, vacant21, geometry) %>%
  rename(CSA = CSA2020, 
         p_vacant = vacant21)

#Baltimore schools
school_outcome <- st_read("https://services1.arcgis.com/mVFRs7NF4iFitgbY/arcgis/rest/services/Pread3/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson")%>%
select(CSA2010, pread317, geometry) %>%
  rename(CSA = CSA2010,
         p_students = pread317)%>%
  st_centroid()

#walk score
walk_score <- st_read("https://services1.arcgis.com/mVFRs7NF4iFitgbY/arcgis/rest/services/Wlksc/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson")%>%
  mutate(changewalk = wlksc17 - wlksc11)%>%
  select(CSA2010, wlksc17, geometry, changewalk) %>%
  rename(CSA = CSA2010,
         walk_score = wlksc17)%>%
  st_centroid()

walk_score_csa <- walk_score %>%
  st_drop_geometry()
walk_score_csa <- left_join(bmorecsa, walk_score_csa, by = c("Community" = "CSA"))

#crime
crime <- st_read("https://services1.arcgis.com/UWYHeuuJISiGmgXx/arcgis/rest/services/Part1_Crime_Beta/FeatureServer/0/query?where=1%3D1&outFields=CrimeCode,Description,Weapon,Post,Location,Latitude,Longitude,GeoLocation,Total_Incidents,CCNumber,CrimeDateTime&outSR=4326&f=json")
  

```

::: {style="display: flex;"}

::: {}

```{r feature_mapcol1, message=FALSE, warning=FALSE}

#change in walk score
ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = walk_score_csa, aes(fill = changewalk), col = "transparent") +
  scale_fill_gradient(
    high = "#861D05",
    low = "#F5B5AC") +
  geom_sf(data = patapsco, fill = "steelblue", col = "transparent") +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Change in Walk Score",
       title = "2011 to 2017 Change in Walk Score",
       subtitle = "Baltimore City, MD", 
       caption = "Source: Walk Score")

#percent change in housing units
huchange <- all.acs.sf %>%
  dplyr::select(HUnitsPctChange, GEOID) %>%
  dplyr::mutate(HUnitsPctChange = HUnitsPctChange/100)

ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = huchange, aes(fill = HUnitsPctChange), col = "transparent") +
  scale_fill_gradient(
    high = "#864259",
    low = "#F5A6C3", 
    labels = scales::percent) +
  geom_sf(data = patapsco, fill = "steelblue", col = "transparent") +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Percent Change",
       title = "2017 to 2022 Percent Change in Number of Housing Units",
       subtitle = "Baltimore City, MD", 
       caption = "Source: 5-year ACS, U.S. Census Bureau")

```

:::

::: {}

```{r feature_mapcol2, message=FALSE, warning=FALSE}

#colleges

ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = huchange, fill = "gray60", col = "gray65") +
  geom_sf(data = patapsco, fill = "steelblue", col = "transparent") +
  geom_sf(data = bmore_colleges, col = "orange", fill = "orange4", shape = 25, size = 3, alpha = 0.8) +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "none", legend.key.width = unit(1.5, "cm")) +
  labs(title = "Colleges and Universities",
       subtitle = "Baltimore City, MD", 
       caption = "Source: Open Baltimore")

#pcent vacant lots
bmore_p_lots_sf <- bmore_p_lots %>%
  dplyr::mutate(p_vacant = p_vacant/100)

ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = bmore_p_lots_sf, aes(fill = p_vacant), col = "transparent") +
  scale_fill_gradient(
    high = "#0F4600",
    low = "#67A87A", 
    labels = scales::percent) +
  geom_sf(data = patapsco, fill = "steelblue", col = "transparent") +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Vacancy Rate",
       title = "2021 Vacancy Rate per CSA",
       subtitle = "Baltimore City, MD", 
       caption = "Source: Open Baltimore")

```

:::

::::

## Logistic Regression

```{r additionalvar, message=FALSE, warning=FALSE, include=FALSE}
p_load(nngeo,FNN,tibble, caret)

bmore_hoods <- bmore_p_lots %>%
  select(-p_vacant)

bmore_CSA_data <- bmore_p_lots %>%
  st_drop_geometry()%>%
  left_join(bmore_business)%>%
  st_as_sf()

bmore_CSA_data <- st_join(bmore_CSA_data, school_outcome, left = TRUE)%>%
  mutate(CSA = coalesce(CSA.x, CSA.y)) %>%
  select(-CSA.x, -CSA.y)%>%
mutate(across(everything(), ~replace_na(., 0)))

bmore_CSA_data <- st_join(bmore_CSA_data, walk_score, left = TRUE)%>%
  mutate(CSA = coalesce(CSA.x, CSA.y)) %>%
  select(-CSA.x, -CSA.y)%>%
mutate(across(everything(), ~replace_na(., 0)))

coldist <- baltimore_tracts
coldist$nearest_college_index <- st_nearest_feature(coldist, bmore_colleges)
coldist <- coldist %>%
  rowwise() %>%
  mutate(nearest_college = list(bmore_colleges[nearest_college_index, ]))
coldist <- coldist %>%
  mutate(coldist = st_distance(geometry, nearest_college$geometry))%>%
  select(-nearest_college_index,
         -nearest_college)%>%
  rename(collegedist = coldist)%>%
  st_drop_geometry()

acs.hoods <- all.acs.sf %>%
  st_transform(crs = st_crs(bmore_CSA_data))%>%
  st_centroid()%>%
  st_join(bmore_CSA_data, join = st_intersects)%>%
  mutate(NAME = coalesce(NAME.x, NAME.y)) %>%
  select(-NAME.x, -NAME.y)

acs.hoods <- acs.hoods %>%
  left_join(coldist)

acs.hoods <- acs.hoods %>%
  select(-STATEFP,
         -COUNTYFP,
         -TRACTCE,
         -NAMELSAD,
         -MTFCC,
         -FUNCSTAT,
         -ALAND,
         -AWATER,
         -INTPTLAT,
         -INTPTLON,
         -NAME) %>%
  st_drop_geometry()%>%
  left_join(bmore_bids)%>%
  mutate(across(where(is.numeric), ~replace_na(., 0)),
         across(where(is.character), ~replace_na(., "Unknown")))
```


To predict gentrification, we will utilize a logistic regression model.
```{r modelling, warning=FALSE, message=FALSE}
set.seed(678)

p_load(stargazer)

all.acs.reg <- acs.hoods 
all.acs.reg <- all.acs.reg %>%
  select(-(ends_with("22")),
         -(ends_with("12")),
         -genindex,
         -CSA,
         -RentPctChange,
         -HomeValuePctChange,
         -MedianRent17,
         -MedianHouseholdIncome17,
         -MedianRent22,
-BachelorsDegree17,
         -MedianHouseholdIncome22,
         -MedianHomeValue22,
         -MedianHouseholdIncome22,
         -percentHighInc22,
         -percentHighInc12,
         -WhiteAlone17,
         -GradProfessionalDegree17,
-MovedWithinCounty17,
         -MovedAbroad17,
         -OwnerOccupiedHouseholdSize17,
         -RenterOccupiedSize17,
         -MedianHomeValue17,
-DiffStateMovePct17,
-WhiteAlonePct17,
-AbroadMovePct17,
-collegedist,
-SStateMovePctChange,
         -inflation.adjHH17,
         -NonFamilyHouseholds17,
-VacantUnitsPctChange)%>%
mutate(walk_school = p_students * walk_score)%>%
mutate(business2 = changebiz ^2)%>%
mutate(upcoming = (changewalk * SStateMovePct17))%>%
select(-p_students,
-walk_score,
-changebiz,
-business_count,
-changewalk)


train <- all.acs.reg %>%
  sample_frac(.75)

train_index <- as.numeric(rownames(train))

test <- all.acs.reg[-train_index, ]

reg.gentrify <- glm(gentrify ~ ., data = 
                    train %>%
                      select(-GEOID,
                             -ChangeInLowIncPct,
                             -ChangeInHighIncPct),
                    family = "binomial"(link = "logit"))

stargazer(reg.gentrify, type = "text", out = "regression_summary.txt", title = "Regression Results", 
          label = "tab:regression_results", align = TRUE, 
          ci = TRUE, ci.level = 0.95, single.row = TRUE, 
          star.cutoffs = c(0.05, 0.01, 0.001), 
          notes = c("*** p<0.001", "** p<0.01", "* p<0.05"), 
          notes.align = "l", notes.label = "Significance levels:")
```

The regression results reveal important insights into the factors influencing gentrification risk within the studied area. Among the predictors, MovedFromSameState17, IncPctChange, HUnitsPctChange, and OOSizePctChange stand out as statistically significant contributors to the likelihood of gentrification. These findings suggest that areas with an increase in housing units, owner-occupied household size, and income are more prone to gentrification pressures, which aligns with literature that has been conducted on the indicators of gentrification. Surprisingly, other features in the model do not demonstrate a significant relationship with gentrification risk, highlighting the nuanced nature of this phenomenon and limitations to predictive modeling.

The model's accuracy of 0.78 indicates that it correctly predicts gentrification status approximately 78% of the time, showcasing its potential utility in identifying at-risk neighborhoods. The sensitivity and specificity are reasonably balanced at 0.6154 and 0.8378, meaning the model is slightly better than chance at identifying true positives. 

```{r confusionmatrix, warning=FALSE, message=FALSE, include=FALSE}
testProbs <- 
  data.frame(class = test$gentrify,
             probs = predict(reg.gentrify, test, type = "response"))

testProbs %>%
  mutate(predClass = ifelse(probs >= .5, "1", "0"), 
         predClass = factor(predClass, levels = c("0", "1")),  
         class = factor(class, levels = c("0", "1"))) %>% 
  { caret::confusionMatrix(.$predClass, .$class, positive = "1") }
```

```{r probdist, warning=FALSE, message=FALSE}
p_load(ggplot2)
palette_4_colors <- c("#e4572e","#17bebb","#ffc914","#A379C9")
root.dir = "https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/DATA/"
source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")

ggplot(testProbs, aes(x = probs, fill = as.factor(class))) + 
  geom_density() +
  facet_grid(class ~ .) +
  scale_fill_manual(values = palette_4_colors) + xlim(0, 1) +
  labs(x = "Gentrify", y = "Density of probabilities",
       title = "Distribution of predicted probabilities by observed outcome") +
  plotTheme() + theme(strip.text.x = element_text(size = 18),
        legend.position = "none")+
  theme(text = element_text(family = "Times New Roman", size = 12), 
        plot.title = element_text(face = "bold", size = 14),
        plot.subtitle = element_text(size = 12),
        plot.caption = element_text(size = 8))
```
The higher peak to the left in the top chart indicates that the model is more confident in predicting non-gentrification instances (class 0) with lower probabilities (closer to 0). This suggests that there are clear features or patterns in the data that the model identifies as indicative of non-gentrification.

The more evenly distributed curve in the bottom chart suggests that the model's predicted probabilities for gentrification instances (class 1) are spread out across a wider range. The slight peak between 0.5 and 0.75 indicates that there are instances where the model predicts a moderate to high likelihood of gentrification, but with some variability.

Overall, these patterns highlight that the model has greater confidence identifying non-gentrification over gentrification. 

## Model Performance

Overall, our model performs well in terms of predicting gentrificiation. Though the model is limited by the lack of observations, the ROC curve still has an AUC value of 0.761, underscoring that the model performs well across all thresholds.

```{r ROCcurve, message=FALSE, warning=FALSE, include=FALSE}
p_load(gridExtra, pROC)

aucTable <- testProbs %>% 
  summarize(AUC = as.numeric(auc(roc(class, probs)))) %>% 
  mutate(AUC = as.character(round(AUC, 3)))

mutate(testProbs.thresholds, pointSize = ifelse(Threshold == .48, 24, 16)) %>%
  ggplot(aes(Rate_FP, Rate_TP)) + 
  geom_point(aes(shape = pointSize)) + geom_line() + scale_shape_identity() +
  geom_abline(slope = 1, intercept = 0, size = 1.5, color = 'grey') +
  annotation_custom(tableGrob(aucTable, rows = NULL), xmin = .45, xmax = 1, ymin = 0, ymax = .45) +
  labs(title="ROC Curve", x="False Positive Rate", y="True Positive Rate") +
  plotTheme()+
  theme(text = element_text(family = "Times New Roman", size = 12), 
        plot.title = element_text(face = "bold", size = 14),
        plot.subtitle = element_text(size = 12),
        plot.caption = element_text(size = 8))
```
The threshold performance curve further provides insights into the model's behavior. As shown in graph below, the accuracy, true positive rate (TPR), and false positive rate (FPR) vary with percentile cut off threshold use for creating our binary gentrification variable.

At lower percentiles, the model is more likely to classify tracts as gentrifying, which increases the TPR but also leads to a higher FPR. This indicates that while the model captures more tracts that do gentrify, it also generates more false positives. As the threshold increases, the TPR decreases while the FPR also decreases, meaning the model becomes more conservative in predicting gentrification, thus reducing the number of false positives but also missing some true positives.

For the purposes of this project, we focused on minimizing false positives, which led to our high cutoff threshold. However, in the future, this threshold can be adjusted to meet different objectives. For instance, our current model, with its high cutoff, is suitable for private developers looking to invest in gentrifying neighborhoods. Conversely, if the model were to be used by a government agency to plan for rental assistance, the cutoff threshold would need to be lowered to reduce the risk of missing areas that might benefit from such programs.

```{r thresholds, warning=FALSE, message=FALSE}
iterateThresholds <- function(data, observedClass, predictedProbs) {
  observedClass <- enquo(observedClass)
  predictedProbs <- enquo(predictedProbs)
  
  x <- 0.01
  all_prediction <- data.frame()
  
  while (x <= 1) {
    this_prediction <- data %>%
      mutate(predclass = ifelse(!!predictedProbs > x, 1, 0)) %>%
      count(predclass, !!observedClass) %>%
      summarize(
        Count_TN = sum(n[predclass == 0 & !!observedClass == 0]),
        Count_TP = sum(n[predclass == 1 & !!observedClass == 1]),
        Count_FN = sum(n[predclass == 0 & !!observedClass == 1]),
        Count_FP = sum(n[predclass == 1 & !!observedClass == 0]),
        Rate_TP = Count_TP / (Count_TP + Count_FN),
        Rate_FP = Count_FP / (Count_FP + Count_TN),
        Rate_FN = Count_FN / (Count_FN + Count_TP),
        Rate_TN = Count_TN / (Count_TN + Count_FP),
        Accuracy = (Count_TP + Count_TN) / (Count_TP + Count_TN + Count_FN + Count_FP),
        Threshold = round(x, 2),
        .groups = 'drop'
      )
    
    all_prediction <- rbind(all_prediction, this_prediction)
    x <- x + .01
  }
  
  return(all_prediction)
}

testProbs.thresholds <- iterateThresholds(
  data = testProbs, 
  observedClass = class, 
  predictedProbs = probs
)

ggplot(testProbs.thresholds, aes(x = Threshold)) +
  geom_line(aes(y = Accuracy, color = "Accuracy")) +
  geom_line(aes(y = Rate_TP, color = "True Positive Rate")) +
  geom_line(aes(y = Rate_FP, color = "False Positive Rate")) +
  scale_color_manual(values = c("Accuracy" = "blue", "True Positive Rate" = "green", "False Positive Rate" = "red")) +
  labs(title = "Model Performance Across Different Percentile Cutoffs",
       x = "Percentile", y = "Rate") +
  theme_minimal() +
  theme(legend.title = element_blank(),
        legend.position = "bottom",
        text = element_text(family = "Times New Roman", size = 12),
        plot.title = element_text(face = "bold", size = 14),
        plot.subtitle = element_text(size = 12),
        plot.caption = element_text(size = 8))
```

# Cross Validation

Overall, our model 
```{r spatialcrossval, message=FALSE, warning=FALSE, include=FALSE}
acs.cv <- acs.hoods %>%
left_join(baltimore_tracts)%>%
  mutate(across(where(is.numeric), ~replace_na(., 0)),
         across(where(is.numeric), ~replace(., is.infinite(.), 0)))%>%
mutate(walk_school = p_students * walk_score,
business2 = changebiz ^2,
upcoming = (changewalk * SStateMovePct17))

reg.vars <- c("TotalPopulation17", "TotalHousingUnits17",
                      "VacantHousingUnits17", "MovedFromSameState17", "MovedFromDifferentState17",
                      "FamilyHouseholds17", "PopChangePct", "HUnitsPctChange",
                      "IncPctChange", "GradPct17", "CountyWWMovePct17",
                      "SStateMovePct17", "BachelorsPct17", "WhiteAlonePctChange",
                      "GradPctChange", "CountyWWMovePctChange", "DiffStateMovePctChange",
                      "AbroadMovePctChange", "BachelorsPctChange", "OOSizePctChange",
                      "ROSizePctChange", "FamHHPctChange", "NonFamHHPctChange",
                      "ChangeInHighIncPct", "ChangeInLowIncPct", "gentrify",
                      "p_vacant", "tractbids", "walk_school",
                      "business2", "upcoming")

reg.spatialCV <- crossValidate(
  dataset = acs.cv,
  id = "GEOID",
  dependentVariable = "gentrify",
  indVariables = reg.vars)%>%
select(GEOID, gentrify, Prediction)%>%
mutate(error = Prediction - gentrify)

reg.summary <- reg.spatialCV %>%
group_by(GEOID)%>%
summarize(Mean_Error = mean(Prediction - , na.rm = T),
              MAE = mean(abs(Mean_Error), na.rm = T),
              SD_MAE = mean(abs(Mean_Error), na.rm = T))

#tm_shape(reg.spatialCV)+
#tm_polygons(col = "Prediction")
```

```{r prediction_map, warning=FALSE, message=FALSE}

ggplot() +
  geom_sf(data = water_bound, fill = "steelblue") +
  geom_sf(data = md_bound, fill = "gray80", col = "gray75") +
  geom_sf(data = reg.spatialCV, aes(fill = Prediction), col = "transparent") +
  scale_fill_gradient(
    high = "#862805",
    low = "#EC9D1F") +
  geom_sf(data = patapsco, fill = "steelblue", col = "transparent") +
  theme_void() +
  xlim(-76.75, -76.48) +
  ylim(39.2, 39.38) +
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) +
  labs(fill = "Predicted GI",
       title = "Predicted Gentrification Index",
       subtitle = "Baltimore City, MD")

```


# Conclusion

Measuring gentrification can be challenging, primarily due to the complexity of its definition. However, this model addresses this challenge by focusing on observable characteristics that the average resident can recognize. While advanced statistical models may have policy implications, the primary aim of this model is to empower city officials and residents to identify gentrification in their neighborhoods early on and take proactive steps to prevent displacement before it becomes a pressing issue.

The results of the model indicate factors such as increased housing units, larger owner-occupied household sizes, and income growth correlate with a greater risk of gentrification in Baltimore City, Maryland. These insights align with the literature on gentrification and most of these changes could be observed by the average resident.  

The model's accuracy rate of 78% highlights its potential use as a tool to identify at-risk neighborhoods. Currently, it excels more in predicting indicators that an area is not undergoing gentrification, however, fine-tuning the model with adjusted thresholds could lead to a more cohesive and accurate prediction of areas at risk. While the model could use further refinement, it serves as an initial step towards providing insights into visible indicators of gentrification for city officials and local residents to empower communities and curb displacement. 







